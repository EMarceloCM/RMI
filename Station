import java.io.File;
import java.io.IOException;
import java.rmi.RemoteException;
import java.rmi.server.UnicastRemoteObject;
import javax.sound.sampled.*;


public class Station extends UnicastRemoteObject implements StationInterface {
    private final String stationName;
    private volatile boolean tonePlaying = false; // controla o thread gerador de tom

    public Station(String stationName) throws RemoteException {
        super();
        this.stationName = stationName;
    }

    @Override
    public void playBirdSong(int songId) throws RemoteException {
        System.out.println("[" + stationName + "] solicitada reprodução de canto de pássaro com ID: " + songId);
        String caminho = "audios" + File.separator + "bird" + songId + ".wav";
        File arquivo = new File(caminho);

        if (!arquivo.exists()) {
            System.err.println("[" + stationName + "] Arquivo não encontrado: " + caminho);
            return;
        }

        try (AudioInputStream audioIn = AudioSystem.getAudioInputStream(arquivo)) {
            AudioFormat format = audioIn.getFormat();
            DataLine.Info info = new DataLine.Info(Clip.class, format);
            Clip clip = (Clip) AudioSystem.getLine(info);
            clip.open(audioIn);
            clip.start();

            System.out.println("[" + stationName + "] tocando arquivo: " + arquivo.getName());

            clip.addLineListener(event -> {
                if (event.getType() == LineEvent.Type.STOP) {
                    clip.close();
                    System.out.println("[" + stationName + "] reprodução encerrada: " + arquivo.getName());
                }
            });
        } catch (UnsupportedAudioFileException | LineUnavailableException | IOException ex) {
            System.err.println("[" + stationName + "] Erro ao tocar áudio: " + ex.getMessage());
            ex.printStackTrace();
        }
    }

    @Override
    public void changeSoundPattern(String pattern) throws RemoteException {
        System.out.println("[" + stationName + "] alterando padrão de som para: \"" + pattern + "\"");

        tonePlaying = false;

        if (pattern == null || pattern.trim().isEmpty()) {
            System.out.println("[" + stationName + "] padrão vazio recebido: parando qualquer tom.");
            return;
        }

        // Cria e inicia um thread para gerar um tom contínuo (senoidal), frequência derivada do 'pattern'
        Thread toneThread = new Thread(() -> {
            tonePlaying = true;
            try {
                // Converte o texto do pattern em frequência (exemplo simples)
                // Por exemplo, soma de códigos dos caracteres modulado em um intervalo audible (200Hz..1000Hz)
                int sum = 0;
                for (char c : pattern.toCharArray()) sum += c;
                float frequency = 200 + (sum % 801); // entre 200Hz e 1000Hz

                int durationSec = 10;
                float sampleRate = 44100;
                int numSamples = (int) (durationSec * sampleRate);
                byte[] buffer = new byte[2 * numSamples];

                // Preenche o buffer com onda senoidal
                for (int i = 0; i < numSamples; i++) {
                    double angle = 2.0 * Math.PI * i * frequency / sampleRate;
                    short valor = (short) (Math.sin(angle) * Short.MAX_VALUE);
                    // valor baixo (LSB)
                    buffer[2 * i]     = (byte) (valor & 0xff);
                    // valor alto (MSB)
                    buffer[2 * i + 1] = (byte) ((valor >> 8) & 0xff);
                }

                // Define formato de áudio PCM 16 bits, mono, 44.1kHz
                AudioFormat format = new AudioFormat(
                    sampleRate,
                    16,
                    1,
                    true,
                    false
                );
                try (SourceDataLine line = AudioSystem.getSourceDataLine(format)) {
                    line.open(format);
                    line.start();

                    System.out.println("[" + stationName + "] tocando tom de frequência " 
                            + String.format("%.1fHz", frequency));

                    int bloco = 4096;
                    for (int offset = 0; offset < buffer.length; offset += bloco) {
                        if (!tonePlaying) {
                            break;
                        }
                        int bytesParaEscrever = Math.min(bloco, buffer.length - offset);
                        line.write(buffer, offset, bytesParaEscrever);
                    }

                    line.drain();
                    line.stop();
                    line.close();
                    System.out.println("[" + stationName + "] tom interrompido/encerrado.");
                }
            } catch (LineUnavailableException ex) {
                System.err.println("[" + stationName + "] Erro ao gerar tom: " + ex.getMessage());
                ex.printStackTrace();
            }
        });

        toneThread.start();
    }
}